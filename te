
  {
    question: "Which of the following is NOT a valid method to solve a recurrence relation?",
    options: ["Recursion Tree", "Master Theorem", "Dynamic Programming", "Substitution Method"],
    correct: 2
  },
  {
    question: "What is the time complexity of Merge Sort in the worst case?",
    options: ["O(n^2)", "O(n log n)", "O(n)", "O(log n)"],
    correct: 1
  },
  {
    question: "Which notation describes an upper bound that is not asymptotically tight?",
    options: ["Theta", "Big-Omega", "Big-O", "Little-o"],
    correct: 3
  },
  {
    question: "In Master Theorem, which case applies if f(n) = Θ(n^log_b a)?",
    options: ["Case 1", "Case 2", "Case 3", "Case 4"],
    correct: 1
  },
  {
    question: "Which sorting algorithm maintains a loop invariant stating that the array is sorted till the ith element?",
    options: ["Merge Sort", "Bubble Sort", "Insertion Sort", "Quick Sort"],
    correct: 2
  },
  {
    question: "Which design strategy solves sub-problems only once and stores the results?",
    options: ["Divide and Conquer", "Greedy", "Dynamic Programming", "Backtracking"],
    correct: 2
  },
  {
    question: "What is the best case complexity of Quick Sort?",
    options: ["O(n^2)", "O(n log n)", "O(log n)", "O(n)"],
    correct: 1
  },
  {
    question: "Which recurrence relation does the merge sort algorithm follow?",
    options: ["T(n) = 2T(n/2) + n", "T(n) = T(n/2) + 1", "T(n) = T(n-1) + n", "T(n) = 2T(n-1) + 1"],
    correct: 0
  },
  {
    question: "In loop invariant proof, what is proven during initialization?",
    options: ["Condition holds before loop", "Condition holds at every iteration", "Condition holds after loop", "Condition is irrelevant"],
    correct: 0
  },
  {
    question: "What is the time complexity of Strassen’s Matrix Multiplication Algorithm?",
    options: ["O(n^3)", "O(n^2.81)", "O(n log n)", "O(n^2)"],
    correct: 1
  },
  {
    question: "Which algorithm solves the problem of finding the minimum spanning tree using a greedy approach?",
    options: ["Prim's algorithm", "Bellman-Ford algorithm", "Floyd-Warshall algorithm", "Dijkstra's algorithm"],
    correct: 0
  },
  {
    question: "Which problem does not exhibit optimal substructure?",
    options: ["Longest Common Subsequence", "Matrix Chain Multiplication", "0/1 Knapsack", "Travelling Salesman Problem"],
    correct: 3
  },
  {
    question: "What is the best case time complexity of binary search?",
    options: ["O(log n)", "O(n)", "O(1)", "O(n log n)"],
    correct: 2
  },
  {
    question: "Which technique is not used in Dynamic Programming?",
    options: ["Overlapping Subproblems", "Memoization", "Divide and Conquer", "Backtracking"],
    correct: 3
  },
  {
    question: "In asymptotic notation, which notation gives the tightest upper bound?",
    options: ["O(n^2)", "Ω(n)", "Θ(n log n)", "o(n)"],
    correct: 0
  },
  {
    question: "Which algorithm is not based on Divide and Conquer?",
    options: ["Merge Sort", "Quick Sort", "Floyd-Warshall", "Binary Search"],
    correct: 2
  },
  {
    question: "Which sorting algorithm is not stable?",
    options: ["Bubble Sort", "Merge Sort", "Quick Sort", "Insertion Sort"],
    correct: 2
  },
  {
    question: "Which algorithm is used for All-Pairs Shortest Path problem?",
    options: ["Bellman-Ford", "Floyd-Warshall", "Dijkstra", "Prim"],
    correct: 1
  },
  {
    question: "Which of the following recurrence relations does Strassen’s algorithm follow?",
    options: ["T(n) = 8T(n/2) + O(n^2)", "T(n) = 7T(n/2) + O(n^2)", "T(n) = 6T(n/2) + O(n^2)", "T(n) = 9T(n/2) + O(n^2)"],
    correct: 1
  },
  {
    question: "Which algorithm is used to detect negative weight cycles in a graph?",
    options: ["Dijkstra's algorithm", "Prim's algorithm", "Kruskal's algorithm", "Bellman-Ford algorithm"],
    correct: 3
  },
  {
    question: "What is the solution to the recurrence relation T(n) = 2T(n/2) + n^2?",
    options: ["O(n^2)", "O(n log n)", "O(n^2 log n)", "O(n)"],
    correct: 2
  },
  {
    question: "What is the recurrence for binary search?",
    options: ["T(n) = T(n-1) + 1", "T(n) = T(n/2) + 1", "T(n) = 2T(n/2) + 1", "T(n) = T(n) + 1"],
    correct: 1
  },
  {
    question: "What is the best method to solve T(n) = T(n/2) + n?",
    options: ["Substitution", "Recursion Tree", "Master Theorem", "All of the above"],
    correct: 3
  },
  {
    question: "Which is not an example of greedy algorithm?",
    options: ["Prim’s algorithm", "Fractional Knapsack", "Dijkstra’s algorithm", "Matrix Chain Multiplication"],
    correct: 3
  },
  {
    question: "What is the base condition in recurrence relations?",
    options: ["Smallest input size result", "Maximum input size", "Intermediate steps", "Worst case input"],
    correct: 0
  },
  {
    question: "Which algorithm has the worst-case time complexity O(n^2) but best-case O(n log n)?",
    options: ["Quick Sort", "Heap Sort", "Merge Sort", "Bubble Sort"],
    correct: 0
  },
  {
    question: "Which of the following is a Divide and Conquer algorithm?",
    options: ["Dijkstra’s algorithm", "Heap Sort", "Merge Sort", "Prim’s algorithm"],
    correct: 2
  },
  {
    question: "Which problem is an example of NP-complete?",
    options: ["Travelling Salesman Problem", "Longest Common Subsequence", "Prim’s algorithm", "Bellman-Ford"],
    correct: 0
  },
  {
    question: "Which method is used to prove the correctness of loops?",
    options: ["Greedy strategy", "Loop Invariant", "Backtracking", "Master Theorem"],
    correct: 1
  },
  {
    question: "What is the main idea behind Greedy algorithms?",
    options: ["Global optimization", "Try all options", "Make the best choice at each step", "Divide into sub-problems"],
    correct: 2
  },
  {
    question: "Which property is required for greedy algorithms to work optimally?",
    options: ["Memoization", "Loop Invariant", "Greedy-choice property", "Randomization"],
    correct: 2
  },
  {
    question: "In the Master Theorem, what does 'a' represent?",
    options: ["Work done outside recursion", "Input size", "Number of subproblems", "Constant overhead"],
    correct: 2
  },
  {
    question: "Which sorting algorithm has a recurrence T(n) = T(n/2) + O(1)?",
    options: ["Binary Insertion Sort", "Heap Sort", "Binary Search", "Quick Sort"],
    correct: 2
  },
  {
    question: "Which algorithm uses a min-heap data structure in its implementation?",
    options: ["Prim’s Algorithm", "Kruskal’s Algorithm", "Merge Sort", "Bubble Sort"],
    correct: 0
  },
  {
    question: "Which algorithm has the same asymptotic time complexity as Merge Sort?",
    options: ["Heap Sort", "Bubble Sort", "Quick Sort Worst Case", "Insertion Sort"],
    correct: 0
  },
  {
    question: "Which is not a sorting algorithm?",
    options: ["Quick Sort", "Merge Sort", "Binary Search", "Heap Sort"],
    correct: 2
  },
  {
    question: "Which algorithm solves single-source shortest path in graphs with negative weights?",
    options: ["Dijkstra", "Prim", "Kruskal", "Bellman-Ford"],
    correct: 3
  },
  {
    question: "What is the best-case time complexity of Insertion Sort?",
    options: ["O(n^2)", "O(n log n)", "O(n)", "O(log n)"],
    correct: 2
  },
  {
    question: "What is the main reason Merge Sort is preferred over Quick Sort in linked lists?",
    options: ["Less comparisons", "Stable sorting", "No random access needed", "Space efficiency"],
    correct: 2
  },
  {
    question: "Which algorithm uses divide-and-conquer and achieves logarithmic depth of recursion?",
    options: ["Quick Sort", "Merge Sort", "Binary Search", "Bubble Sort"],
    correct: 2
  },
  {
    question: "Which of the following is used to solve recurrence relations?",
    options: ["Loop Invariant", "Amortized Analysis", "Master Method", "Greedy Choice Property"],
    correct: 2
  },
  {
    question: "Which is the best case input for Quick Sort?",
    options: ["Sorted Array", "Reverse Sorted", "Random Array", "Pivot at center every time"],
    correct: 3
  },
  {
    question: "Which algorithm guarantees optimal solution for the fractional knapsack problem?",
    options: ["Dynamic Programming", "Greedy Algorithm", "Backtracking", "Divide and Conquer"],
    correct: 1
  },
  {
    question: "Which is an example of a non-polynomial time algorithm?",
    options: ["Bubble Sort", "Insertion Sort", "TSP Brute Force", "Binary Search"],
    correct: 2
  },
  {
    question: "Which problem can be solved using Huffman Coding?",
    options: ["Compression", "Shortest Path", "MST", "TSP"],
    correct: 0
  },
  {
    question: "Which recurrence represents Quick Sort's worst-case?",
    options: ["T(n) = T(n/2) + n", "T(n) = T(n-1) + O(n)", "T(n) = 2T(n/2) + n", "T(n) = T(n) + 1"],
    correct: 1
  },
  {
    question: "Which case of Master Theorem applies when f(n) is polynomially larger than n^log_b a?",
    options: ["Case 1", "Case 2", "Case 3", "None"],
    correct: 2
  },
  {
    question: "Which of the following is NOT a valid method to solve a recurrence relation?",
    options: ["Recursion Tree", "Master Theorem", "Dynamic Programming", "Substitution Method"],
    correct: 2
  },
  {
    question: "Which of the following asymptotic notations provides an upper bound?",
    options: ["Big Theta", "Big Oh", "Big Omega", "None of the above"],
    correct: 1
  },
  {
    question: "Which sorting algorithm has the best worst-case time complexity?",
    options: ["Merge Sort", "Quick Sort", "Heap Sort", "Bubble Sort"],
    correct: 0
  }











[
  {
    "question": "Which case analysis helps in understanding the algorithm's behavior under random input?",
    "options": [
      "Best Case",
      "Average Case",
      "Worst Case",
      "None"
    ],
    "correct": 1
  },
  {
    "question": "Which notation represents the tight bound of an algorithm?",
    "options": [
      "Big Oh",
      "Big Omega",
      "Big Theta",
      "Little o"
    ],
    "correct": 2
  },
  {
    "question": "Which sorting algorithm is stable and has worst-case time complexity of O(n^2)?",
    "options": [
      "Quick Sort",
      "Heap Sort",
      "Selection Sort",
      "Insertion Sort"
    ],
    "correct": 3
  },
  {
    "question": "What is the time complexity of Bubble Sort in the best case?",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(log n)"
    ],
    "correct": 0
  },
  {
    "question": "Which type of algorithm design uses recursive calls to divide problems?",
    "options": [
      "Dynamic Programming",
      "Divide and Conquer",
      "Greedy",
      "Brute Force"
    ],
    "correct": 1
  },
  {
    "question": "What is the role of loop invariant in algorithm analysis?",
    "options": [
      "Optimizes the loop",
      "Checks correctness during iterations",
      "Improves time complexity",
      "Calculates memory used"
    ],
    "correct": 1
  },
  {
    "question": "Which method solves recurrence by expanding it recursively?",
    "options": [
      "Master Method",
      "Recursion Tree",
      "Substitution",
      "Greedy"
    ],
    "correct": 1
  },
  {
    "question": "Which property is essential for an algorithm to ensure it eventually finishes?",
    "options": [
      "Correctness",
      "Finiteness",
      "Effectiveness",
      "Input"
    ],
    "correct": 1
  },
  {
    "question": "If an algorithm takes T(n) = 2T(n/2) + n, what is its time complexity?",
    "options": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ],
    "correct": 2
  },
  {
    "question": "Which is not a property of an algorithm?",
    "options": [
      "Input",
      "Output",
      "Infinite steps",
      "Effectiveness"
    ],
    "correct": 2
  },
  {
    "question": "Which algorithm uses divide and conquer to sort the array in O(n log n) time?",
    "options": [
      "Bubble Sort",
      "Selection Sort",
      "Merge Sort",
      "Insertion Sort"
    ],
    "correct": 2
  },
  {
    "question": "In Strassen's matrix multiplication, how many multiplications are used?",
    "options": [
      "7",
      "8",
      "9",
      "6"
    ],
    "correct": 0
  },
  {
    "question": "Which of the following problems can be solved using divide and conquer?",
    "options": [
      "Fibonacci Series",
      "Binary Search",
      "DFS",
      "Kruskal\u2019s Algorithm"
    ],
    "correct": 1
  },
  {
    "question": "What is the worst-case time complexity of quick sort?",
    "options": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ],
    "correct": 0
  },
  {
    "question": "What strategy is used in the Merge Sort algorithm?",
    "options": [
      "Greedy",
      "Divide and Conquer",
      "Backtracking",
      "Dynamic Programming"
    ],
    "correct": 1
  },
  {
    "question": "Which step is not a part of divide and conquer?",
    "options": [
      "Divide",
      "Conquer",
      "Merge",
      "Select"
    ],
    "correct": 3
  },
  {
    "question": "What is the complexity of Max-Min problem using divide and conquer?",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(log n)"
    ],
    "correct": 0
  },
  {
    "question": "Which divide-and-conquer algorithm uses two pointers to sort?",
    "options": [
      "Bubble Sort",
      "Merge Sort",
      "Heap Sort",
      "Counting Sort"
    ],
    "correct": 1
  },
  {
    "question": "In quick sort, worst-case occurs when pivot is chosen as:",
    "options": [
      "Middle element",
      "Random element",
      "Smallest/Largest element",
      "Median"
    ],
    "correct": 2
  },
  {
    "question": "What is the recurrence relation for Merge Sort?",
    "options": [
      "T(n) = T(n-1) + n",
      "T(n) = 2T(n/2) + n",
      "T(n) = T(n/2) + log n",
      "T(n) = 3T(n/2) + 1"
    ],
    "correct": 1
  },
  {
    "question": "Which algorithm is used to find the minimum spanning tree using a greedy approach?",
    "options": [
      "Dijkstra\u2019s",
      "Kruskal\u2019s",
      "Bellman-Ford",
      "Floyd-Warshall"
    ],
    "correct": 1
  },
  {
    "question": "Which of the following is not a greedy algorithm?",
    "options": [
      "Prim's Algorithm",
      "Dijkstra\u2019s Algorithm",
      "Merge Sort",
      "Kruskal's Algorithm"
    ],
    "correct": 2
  },
  {
    "question": "In 0/1 knapsack problem, greedy approach fails because:",
    "options": [
      "It maximizes profit",
      "It minimizes weight",
      "It does not consider optimal substructure",
      "It ignores combinations"
    ],
    "correct": 3
  },
  {
    "question": "Huffman coding algorithm is used for:",
    "options": [
      "Searching",
      "Compression",
      "Sorting",
      "Path finding"
    ],
    "correct": 1
  },
  {
    "question": "Which data structure is commonly used in Prim\u2019s algorithm?",
    "options": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ],
    "correct": 2
  },
  {
    "question": "Which of the following is used in Dijkstra\u2019s algorithm to select the next node?",
    "options": [
      "Random choice",
      "Shortest tentative distance",
      "Longest path",
      "Minimum edge"
    ],
    "correct": 1
  },
  {
    "question": "Which greedy algorithm ensures prefix-free binary codes?",
    "options": [
      "Kruskal\u2019s",
      "Prim\u2019s",
      "Huffman",
      "Bellman-Ford"
    ],
    "correct": 2
  },
  {
    "question": "Which strategy is key to greedy algorithm design?",
    "options": [
      "Divide and conquer",
      "Optimal substructure",
      "Local optimization",
      "Memoization"
    ],
    "correct": 2
  },
  {
    "question": "Which property must be true for greedy algorithm to always give optimal solution?",
    "options": [
      "Greedy-choice property",
      "Backtracking",
      "Loop Invariant",
      "Recursion"
    ],
    "correct": 0
  },
  {
    "question": "Activity Selection Problem is solved using:",
    "options": [
      "Backtracking",
      "Divide and Conquer",
      "Greedy",
      "Dynamic Programming"
    ],
    "correct": 2
  }

  {
    "question": "Which case analysis helps in understanding the algorithm's behavior under random input?",
    "options": [
      "Best Case",
      "Average Case",
      "Worst Case",
      "None"
    ],
    "correct": 1
  },
  {
    "question": "Which notation represents the tight bound of an algorithm?",
    "options": [
      "Big Oh",
      "Big Omega",
      "Big Theta",
      "Little o"
    ],
    "correct": 2
  },
  {
    "question": "Which sorting algorithm is stable and has worst-case time complexity of O(n^2)?",
    "options": [
      "Quick Sort",
      "Heap Sort",
      "Selection Sort",
      "Insertion Sort"
    ],
    "correct": 3
  },
  {
    "question": "What is the time complexity of Bubble Sort in the best case?",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(log n)"
    ],
    "correct": 0
  },
  {
    "question": "Which type of algorithm design uses recursive calls to divide problems?",
    "options": [
      "Dynamic Programming",
      "Divide and Conquer",
      "Greedy",
      "Brute Force"
    ],
    "correct": 1
  },
  {
    "question": "What is the role of loop invariant in algorithm analysis?",
    "options": [
      "Optimizes the loop",
      "Checks correctness during iterations",
      "Improves time complexity",
      "Calculates memory used"
    ],
    "correct": 1
  },
  {
    "question": "Which method solves recurrence by expanding it recursively?",
    "options": [
      "Master Method",
      "Recursion Tree",
      "Substitution",
      "Greedy"
    ],
    "correct": 1
  },
  {
    "question": "Which property is essential for an algorithm to ensure it eventually finishes?",
    "options": [
      "Correctness",
      "Finiteness",
      "Effectiveness",
      "Input"
    ],
    "correct": 1
  },
  {
    "question": "If an algorithm takes T(n) = 2T(n/2) + n, what is its time complexity?",
    "options": [
      "O(log n)",
      "O(n)",
      "O(n log n)",
      "O(n^2)"
    ],
    "correct": 2
  },
  {
    "question": "Which is not a property of an algorithm?",
    "options": [
      "Input",
      "Output",
      "Infinite steps",
      "Effectiveness"
    ],
    "correct": 2
  },
  {
    "question": "Which algorithm uses divide and conquer to sort the array in O(n log n) time?",
    "options": [
      "Bubble Sort",
      "Selection Sort",
      "Merge Sort",
      "Insertion Sort"
    ],
    "correct": 2
  },
  {
    "question": "In Strassen's matrix multiplication, how many multiplications are used?",
    "options": [
      "7",
      "8",
      "9",
      "6"
    ],
    "correct": 0
  },
  {
    "question": "Which of the following problems can be solved using divide and conquer?",
    "options": [
      "Fibonacci Series",
      "Binary Search",
      "DFS",
      "Kruskal\u2019s Algorithm"
    ],
    "correct": 1
  },
  {
    "question": "What is the worst-case time complexity of quick sort?",
    "options": [
      "O(n^2)",
      "O(n log n)",
      "O(log n)",
      "O(n)"
    ],
    "correct": 0
  },
  {
    "question": "What strategy is used in the Merge Sort algorithm?",
    "options": [
      "Greedy",
      "Divide and Conquer",
      "Backtracking",
      "Dynamic Programming"
    ],
    "correct": 1
  },
  {
    "question": "Which step is not a part of divide and conquer?",
    "options": [
      "Divide",
      "Conquer",
      "Merge",
      "Select"
    ],
    "correct": 3
  },
  {
    "question": "What is the complexity of Max-Min problem using divide and conquer?",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(log n)"
    ],
    "correct": 0
  },
  {
    "question": "Which divide-and-conquer algorithm uses two pointers to sort?",
    "options": [
      "Bubble Sort",
      "Merge Sort",
      "Heap Sort",
      "Counting Sort"
    ],
    "correct": 1
  },
  {
    "question": "In quick sort, worst-case occurs when pivot is chosen as:",
    "options": [
      "Middle element",
      "Random element",
      "Smallest/Largest element",
      "Median"
    ],
    "correct": 2
  },
  {
    "question": "What is the recurrence relation for Merge Sort?",
    "options": [
      "T(n) = T(n-1) + n",
      "T(n) = 2T(n/2) + n",
      "T(n) = T(n/2) + log n",
      "T(n) = 3T(n/2) + 1"
    ],
    "correct": 1
  },
  {
    "question": "Which algorithm is used to find the minimum spanning tree using a greedy approach?",
    "options": [
      "Dijkstra\u2019s",
      "Kruskal\u2019s",
      "Bellman-Ford",
      "Floyd-Warshall"
    ],
    "correct": 1
  },
  {
    "question": "Which of the following is not a greedy algorithm?",
    "options": [
      "Prim's Algorithm",
      "Dijkstra\u2019s Algorithm",
      "Merge Sort",
      "Kruskal's Algorithm"
    ],
    "correct": 2
  },
  {
    "question": "In 0/1 knapsack problem, greedy approach fails because:",
    "options": [
      "It maximizes profit",
      "It minimizes weight",
      "It does not consider optimal substructure",
      "It ignores combinations"
    ],
    "correct": 3
  },
  {
    "question": "Huffman coding algorithm is used for:",
    "options": [
      "Searching",
      "Compression",
      "Sorting",
      "Path finding"
    ],
    "correct": 1
  },
  {
    "question": "Which data structure is commonly used in Prim\u2019s algorithm?",
    "options": [
      "Stack",
      "Queue",
      "Heap",
      "Set"
    ],
    "correct": 2
  },
  {
    "question": "Which of the following is used in Dijkstra\u2019s algorithm to select the next node?",
    "options": [
      "Random choice",
      "Shortest tentative distance",
      "Longest path",
      "Minimum edge"
    ],
    "correct": 1
  },
  {
    "question": "Which greedy algorithm ensures prefix-free binary codes?",
    "options": [
      "Kruskal\u2019s",
      "Prim\u2019s",
      "Huffman",
      "Bellman-Ford"
    ],
    "correct": 2
  },
  {
    "question": "Which strategy is key to greedy algorithm design?",
    "options": [
      "Divide and conquer",
      "Optimal substructure",
      "Local optimization",
      "Memoization"
    ],
    "correct": 2
  },
  {
    "question": "Which property must be true for greedy algorithm to always give optimal solution?",
    "options": [
      "Greedy-choice property",
      "Backtracking",
      "Loop Invariant",
      "Recursion"
    ],
    "correct": 0
  },
  {
    "question": "Activity Selection Problem is solved using:",
    "options": [
      "Backtracking",
      "Divide and Conquer",
      "Greedy",
      "Dynamic Programming"
    ],
    "correct": 2
  },
  {
    "question": "Which recurrence relation fits the substitution method T(n) = T(n/2) + 1?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(1)"
    ],
    "correct": 1
  },
  {
    "question": "Which sorting algorithm requires the minimum number of swaps in average case?",
    "options": [
      "Bubble Sort",
      "Insertion Sort",
      "Selection Sort",
      "Quick Sort"
    ],
    "correct": 2
  },
  {
    "question": "What is the best-case complexity of Selection Sort?",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(n^2)",
      "O(log n)"
    ],
    "correct": 2
  },
  {
    "question": "Which of the following recurrence relations can be solved using Master\u2019s Theorem?",
    "options": [
      "T(n) = T(n-1) + n",
      "T(n) = 2T(n/2) + n",
      "T(n) = T(n-1) + log n",
      "T(n) = T(n/3) + n"
    ],
    "correct": 1
  },
  {
    "question": "Which notation best describes the minimum running time?",
    "options": [
      "Big-O",
      "Big-Theta",
      "Big-Omega",
      "Little-o"
    ],
    "correct": 2
  },
  {
    "question": "The time complexity of nested loops is determined by:",
    "options": [
      "Sum of loops",
      "Maximum loop",
      "Product of loops",
      "Minimum loop"
    ],
    "correct": 2
  },
  {
    "question": "Which of the following guarantees algorithm correctness?",
    "options": [
      "Loop termination",
      "Loop invariant",
      "Asymptotic analysis",
      "Recurrence relation"
    ],
    "correct": 1
  },
  {
    "question": "Which sorting algorithm does not perform well on large datasets?",
    "options": [
      "Merge Sort",
      "Quick Sort",
      "Insertion Sort",
      "Heap Sort"
    ],
    "correct": 2
  },
  {
    "question": "What is the key idea behind recursion tree method?",
    "options": [
      "Substitution",
      "Iteration",
      "Drawing subproblems",
      "Guess and check"
    ],
    "correct": 2
  },
  {
    "question": "Which analysis is most pessimistic?",
    "options": [
      "Best Case",
      "Average Case",
      "Worst Case",
      "Amortized Case"
    ],
    "correct": 2
  },
  {
    "question": "What is the depth of the recursion tree in Merge Sort?",
    "options": [
      "log n",
      "n",
      "sqrt(n)",
      "n log n"
    ],
    "correct": 0
  },
  {
    "question": "Which of the following divide-and-conquer algorithms doesn't sort?",
    "options": [
      "Quick Sort",
      "Merge Sort",
      "Strassen\u2019s Multiplication",
      "Heap Sort"
    ],
    "correct": 2
  },
  {
    "question": "Which sorting algorithm performs best when data is already nearly sorted?",
    "options": [
      "Merge Sort",
      "Quick Sort",
      "Insertion Sort",
      "Bubble Sort"
    ],
    "correct": 2
  },
  {
    "question": "The merge operation in merge sort takes how much time?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n^2)",
      "O(1)"
    ],
    "correct": 0
  },
  {
    "question": "Which algorithm breaks a matrix into 4 submatrices?",
    "options": [
      "Floyd-Warshall",
      "Prim\u2019s",
      "Strassen\u2019s",
      "Kruskal\u2019s"
    ],
    "correct": 2
  },
  {
    "question": "What is the advantage of quick sort over merge sort?",
    "options": [
      "Stability",
      "Less space usage",
      "Better worst-case",
      "More accurate"
    ],
    "correct": 1
  },
  {
    "question": "Which algorithm uses a divide and conquer method and is not comparison-based?",
    "options": [
      "Merge Sort",
      "Quick Sort",
      "Counting Sort",
      "Binary Search"
    ],
    "correct": 2
  },
  {
    "question": "Which is faster in practice for random data: quick sort or merge sort?",
    "options": [
      "Quick Sort",
      "Merge Sort",
      "Both same",
      "Depends on input"
    ],
    "correct": 0
  },
  {
    "question": "Which algorithm is not part of divide and conquer family?",
    "options": [
      "Binary Search",
      "Merge Sort",
      "Kruskal's",
      "Strassen's"
    ],
    "correct": 2
  },
  {
    "question": "Which recurrence represents binary search?",
    "options": [
      "T(n) = T(n-1) + 1",
      "T(n) = T(n/2) + 1",
      "T(n) = 2T(n/2) + 1",
      "T(n) = T(n) + n"
    ],
    "correct": 1
  },
  {
    "question": "Which algorithm selects edges in increasing weight order?",
    "options": [
      "Prim\u2019s",
      "Kruskal\u2019s",
      "Dijkstra\u2019s",
      "Bellman-Ford"
    ],
    "correct": 1
  },
  {
    "question": "Which algorithm always selects local optimum first?",
    "options": [
      "Divide and Conquer",
      "Backtracking",
      "Greedy",
      "Dynamic Programming"
    ],
    "correct": 2
  },
  {
    "question": "Which greedy algorithm uses frequency to generate binary codes?",
    "options": [
      "Kruskal",
      "Huffman",
      "Dijkstra",
      "Bellman-Ford"
    ],
    "correct": 1
  },
  {
    "question": "In which algorithm are nodes added based on minimum edge weight?",
    "options": [
      "Kruskal\u2019s",
      "Prim\u2019s",
      "Dijkstra\u2019s",
      "Huffman\u2019s"
    ],
    "correct": 1
  },
  {
    "question": "What is the time complexity of Dijkstra's algorithm using min heap?",
    "options": [
      "O(V^2)",
      "O(V log V + E)",
      "O(E log V)",
      "O(E + V)"
    ],
    "correct": 1
  },
  {
    "question": "In the fractional knapsack, what should be sorted first?",
    "options": [
      "Weights",
      "Profits",
      "Profit/Weight ratio",
      "Items"
    ],
    "correct": 2
  },
  {
    "question": "Which MST algorithm requires cycle checking?",
    "options": [
      "Prim\u2019s",
      "Kruskal\u2019s",
      "Dijkstra\u2019s",
      "Bellman-Ford"
    ],
    "correct": 1
  },
  {
    "question": "Which of these is a greedy algorithm for shortest path?",
    "options": [
      "Prim's",
      "Bellman-Ford",
      "Dijkstra\u2019s",
      "Floyd-Warshall"
    ],
    "correct": 2
  },
  {
    "question": "Which condition fails for 0/1 knapsack using greedy?",
    "options": [
      "Overlapping subproblems",
      "Greedy choice property",
      "Optimal substructure",
      "None"
    ],
    "correct": 1
  },
  {
    "question": "In activity selection, what should be sorted to apply greedy?",
    "options": [
      "Start times",
      "End times",
      "Durations",
      "Profits"
    ],
    "correct": 1
  }
]